var documenterSearchIndex = {"docs":
[{"location":"","page":"Metadata","title":"Metadata","text":"CurrentModule = Metadata","category":"page"},{"location":"#Static","page":"Metadata","title":"Static","text":"","category":"section"},{"location":"","page":"Metadata","title":"Metadata","text":"","category":"page"},{"location":"","page":"Metadata","title":"Metadata","text":"Modules = [Metadata]","category":"page"},{"location":"#Metadata.Metadata","page":"Metadata","title":"Metadata.Metadata","text":"Metadata.jl\n\n(Image: CI) (Image: stable-docs) (Image: dev-docs) (Image: codecov)\n\nIntroduction\n\nThe term \"metadata\" is widely used across very different applications. Therefore, \"metadata\" may translate to very different structures and implementations in code. The Metadata package attempts to provide a generic interface for interacting with metadata in Julia that is agnostic to the exact type of metadata present. This package typically assumes metadata to be a collection of values paired to Symbol keys (e.g., AbstractDict{Symbol,Any}, NamedTuple), but metadata that doesn't perfectly fit this criteria should still work with most methods if adhering to the basic interface.\n\nAttaching Metadata\n\nThe most important method to know is attach_metadata. It's intended to give users a generic way of attaching metadata to any given type without worrying about the particulars what type is appropriate for binding metadata to a particular. For example, attaching metadata to an array should produce something that can act like an array still. Instead of requiring users to know what type is used internally (Metadata.MetaArray), an appropriate type is chosen by default and the method of accessing metadata is the same.\n\njulia> using Metadata\n\njulia> x = ones(2, 2);\n\njulia> meta = (x = 1, y = 2);\n\njulia> mx = attach_metadata(x, meta)\n2×2 attach_metadata(::Matrix{Float64}, ::NamedTuple{(:x, :y), Tuple{Int64, Int64}}\n  • metadata:\n     x = 1\n     y = 2\n)\n 1.0  1.0\n 1.0  1.0\n\njulia> mx.x\n1\n\njulia> mx.y\n2\n\njulia> attach_metadata(x, (x = 1, y = 2, suppress= [:x]))\n2×2 attach_metadata(::Matrix{Float64}, ::NamedTuple{(:x, :y, :suppress), Tuple{Int64, Int64, Vector{Symbol}}}\n  • metadata:\n     x = <suppressed>\n     y = 2\n)\n 1.0  1.0\n 1.0  1.0\n\n\nThere are three things you should notice from the previous example:\n\nThe display is nearly identical to how the parent x would be printed. The only addition is a list of the metadata and the argument used to bind the x and meta.\nWe can access the metadata as if they were properties.\nWe can suppress the printing of any value if metadata(x, :suppress) returns a collection of symbols containing that value.\n\nThere are a limited number of interfaces that require special types for binding metadata. The rest are bound to Metadata.MetaStruct.\n\njulia> mr = attach_metadata(3//5, meta)\nattach_metadata(3//5, ::NamedTuple{(:x, :y), Tuple{Int64, Int64}})\n  • metadata:\n     x = 1\n     y = 2\n\njulia> propertynames(mr)\n(:x, :y)\n\njulia> mr.num\n3\n\njulia> mr.den\n5\n\nHere we attached the same metadata to a rational number. Again, our metadata is now considered the properties of mr, but we can still access the parent's properties.\n\nIf the type you want to attach metadata to is mutable then each instance has a unique global identifier and you may attach metadata to a global dictionary.\n\njulia> x = ones(2, 2);\n\njulia> @attach_metadata(x, meta);\n\njulia> @metadata!(x, :z, 3);\n\njulia> @metadata(x, :z)\n3\n\njulia> Pair(:x, 1) in @metadata(x)\ntrue\n\nIf users want to access all of the metadata from one structure and attach it to another they should instead use share_metadata(src, dst) or copy_metadata(src, dst).\n\njulia> mx = attach_metadata(ones(2, 2), @metadata(x));\n\njulia> mx2 = share_metadata(mx, ones(2, 2));\n\njulia> metadata(mx2) === metadata(mx)\ntrue\n\njulia> mx3 = copy_metadata(mx2, ones(2, 2));\n\njulia> metadata(mx3) === metadata(mx2)\nfalse\n\njulia> metadata(mx3) == metadata(mx2)\ntrue\n\nCreating New Metadata Types\n\nThis package creates a very minimal number of dedicated structures and creating new dedicated structures that use this interface is encouraged.\n\nabstract type AbstractNoop end\n\nstruct Noop <: AbstractNoop end\n\nstruct MetaNoop{P<:AbstractNoop,M} <: AbstractNoop\n    parent::P\n    metadata::M\nend\n\nMetadata.metadata(x::MetaNoop) = getfield(x, :metadata)\nMetadata.unsafe_attach_metadata(x::AbstractNoop, m) = MetaNoop(x, m)\nMetadata.metadata_type(::Type{MetaNoop{P,M}}) where {P,M} = M\n\nArrayInterface.parent_type(::Type{MetaNoop{P,M}}) where {P,M} = P\nBase.parent(x::MetaNoop) = getfield(x, :parent)\n\nIt's advised that Metadata.test_wrapper(MetaNoop, Noop()) is run to ensure it works. Note that using the dot operator (.) that aliases getproperty and setproperty! is not necessary.\n\n\n\n\n\n","category":"module"},{"location":"#Metadata.CopyMetadata","page":"Metadata","title":"Metadata.CopyMetadata","text":"CopyMetadata\n\nInforms operations that may propagate metadata to attach a copy to any new instance created.\n\nwarning: Warning\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.DropMetadata","page":"Metadata","title":"Metadata.DropMetadata","text":"DropMetadata\n\nInforms operations that may propagate metadata to insead drop it.\n\nwarning: Warning\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.GlobalMetadata","page":"Metadata","title":"Metadata.GlobalMetadata","text":"GlobalMetadata <: AbstractDict{UInt,Dict{Symbol,Any}}\n\nStores metadata for instances of types at the module level. It has restricted support for dictionary methods to ensure that references aren't unintentionally \n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MDList","page":"Metadata","title":"Metadata.MDList","text":"MDList(first::MDNode, tail::Union{MDList,NoData})\n\nIterable list of metadata.\n\nwarning: Experimental\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MDNode","page":"Metadata","title":"Metadata.MDNode","text":"MDNode(key, data)\n\nDedicated type for associating metadata with key. This is used to selectively reach metadata using MDNodedata.getmeta(x, key, d). key must be of a singleton type.\n\nwarning: Experimental\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetaIO","page":"Metadata","title":"Metadata.MetaIO","text":"MetaIO(io, meta)\n\nType for storing metadata alongside subtypes of IO.\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetaStruct","page":"Metadata","title":"Metadata.MetaStruct","text":"MetaStruct(p, m)\n\nBinds a parent instance (p) to some metadata (m). MetaStruct is the generic type constructed when attach_metadata(p, m) is called.\n\nSee also: attach_metadata, attach_eachmeta\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetaUnitRange","page":"Metadata","title":"Metadata.MetaUnitRange","text":"MetaUnitRange(x::AbstractUnitRange, meta)\n\nType for storing metadata alongside anything that is subtype of AbstractUnitRange. It is not intended that this be constructed directly. attach_metadata(::AbstractUnitRange, meta) should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetadataPropagation","page":"Metadata","title":"Metadata.MetadataPropagation","text":"MetadataPropagation(::Type{T})\n\nReturns type informing how to propagate metadata of type T. See DropMetadata, CopyMetadata, ShareMetadata.\n\nwarning: Warning\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.NoData","page":"Metadata","title":"Metadata.NoData","text":"NoData\n\nInternal type for the Metadata package that indicates the absence of any metadata. DO NOT store metadata with the value NoData().\n\nwarning: Warning\nThis is not part of the public API and may change without notice.\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.ShareMetadata","page":"Metadata","title":"Metadata.ShareMetadata","text":"ShareMetadata\n\nInforms operations that may propagate metadata to attach a the same metadata to any new instance created.\n\nwarning: Warning\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.attach_global_metadata-Tuple{Any, Union{Dict{String, Any}, Dict{Symbol, Any}}, Module}","page":"Metadata","title":"Metadata.attach_global_metadata","text":"attach_global_metadata(x, meta, m::Module)\n\nAttach metadata meta to the object id of x (objectid(x)) in global metadata of module m.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.attach_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.attach_metadata","text":"attach_metadata(x, m)\n\nGeneric method for attaching metadata m to data x. This method acts as an intermediate step where compatability between x and m is checked using checkmeta.  unsafe_attach_metadata is subsequently used to quickly bind the two without and further checks.\n\nExtended help\n\nIn general, it is not advised to define new attach_metadata methods. Instead, unique types for binding x to metadata should define a new unsafe_attach_metadata method. For example, attaching metadata to AbstractArray types by defining a unique method for unsafe_attach_metadata(x::AbstractArray, m).\n\nSee also: unsafe_attach_metadata, checkmeta\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.checkmeta-Tuple{Any, Any}","page":"Metadata","title":"Metadata.checkmeta","text":"checkmeta([Type{Bool}], x, m)\n\nChecks if the metadata m is compatible with x. If Bool is not included then an error is throw on failure.\n\nwarning: Warning\nThis is experimentaland may change without warning\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.copy_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.copy_metadata","text":"copy_metadata(src, dst) -> attach_metadata(dst, copy(metadata(src)))\n\nCopies the the metadata from src and attaches it to dst. Note that this method specifically calls deepcopy on the metadata of src to ensure that changing the metadata of dst does not affect the metadata of src.\n\nwarning: Warning\nThis is experimental and may change without warning\n\nSee also: share_metadata.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.drop_metadata-Tuple{Any}","page":"Metadata","title":"Metadata.drop_metadata","text":"drop_metadata(x)\n\nwarning: Warning\nThis is experimental and may change without warning\n\nReturns x without metadata attached.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.getmeta-Tuple{Any, Any, Any}","page":"Metadata","title":"Metadata.getmeta","text":"getmeta(x, key, default)\n\nReturn the metadata associated with key, or return default if key is not found.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.getmeta-Tuple{Union{Function, Type}, Any, Any}","page":"Metadata","title":"Metadata.getmeta","text":"getmeta(f::Function, x, key)\n\nReturn the metadata associated with key, or return f(x) if key is not found. Note that this behavior differs from Base.get(::Function, x, keys) in that getmeta passes x to f as an argument (as opposed to f()).\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.global_metadata!-Tuple{Any, Any, Any, Module}","page":"Metadata","title":"Metadata.global_metadata!","text":"global_metadata!(x, k, val, m::Module)\n\nSet the value of x's global metadata in module m associated with the key k to val.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.global_metadata-Tuple{Any, Module}","page":"Metadata","title":"Metadata.global_metadata","text":"global_metadata(x, m::Module)\nglobal_metadata(x, k::Symbol, m::Module)\n\nRetreive metadata associated with the object id of x (objectid(x)) in stored in the global metadata of module m. If the key k is specified only the value associated with that key is returned.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.has_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.has_metadata","text":"has_metadata(x, k)::Bool\n\nReturns true if metadata associated with x has the key k.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.has_metadata-Tuple{Any}","page":"Metadata","title":"Metadata.has_metadata","text":"has_metadata(x)::Bool\n\nReturns true if x has metadata.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.metadata-Tuple{Any}","page":"Metadata","title":"Metadata.metadata","text":"metadata(x)\n\nReturns metadata immediately bound to x. If no metadata is bound to x then Metadata.no_data is returned.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.metadata_summary-Tuple{Any}","page":"Metadata","title":"Metadata.metadata_summary","text":"metadata_summary([io], x)\n\nCreates summary readout of metadata for x.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.metadata_type-Tuple{Any}","page":"Metadata","title":"Metadata.metadata_type","text":"metadata_type(::Type{T})\n\nReturns the type of the metadata associated with T.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.metakey-Tuple{Metadata.MDNode}","page":"Metadata","title":"Metadata.metakey","text":"Metadata.metakey(m)\n\nReturns the key associated withe the metadata m. The only way to attach a key to metadata is through MDNode(key, m).\n\nwarning: Warning\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.properties-Tuple{Any}","page":"Metadata","title":"Metadata.properties","text":"properties(x)\n\nReturns properties associated with bound to x.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.rmkey-Tuple{Metadata.MDNode}","page":"Metadata","title":"Metadata.rmkey","text":"Metadata.rmkey(m::MDNode) -> parent(m)\nMetadata.rmkey(m) -> m\n\nReturns the the metadata key associated bound to m, if m is MDNode. This is only intended for internal use.\n\nwarning: Warning\nThis is experimental and may change without warning\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.share_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.share_metadata","text":"share_metadata(src, dst) -> attach_metadata(dst, metadata(src))\n\nShares the metadata from src by attaching it to dst. The returned instance will have properties that are synchronized with src (i.e. modifying one's metadata will effect the other's metadata).\n\nwarning: Warning\nThis is experimental and may change without warning\n\nSee also: copy_metadata.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.stripmeta-Tuple{Any}","page":"Metadata","title":"Metadata.stripmeta","text":"stripmeta(x) -> (data, metadata)\n\nReturns the the data and metadata immediately bound to x.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.test_wrapper-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Metadata","title":"Metadata.test_wrapper","text":"test_wrapper(::Type{WrapperType}, x::X)\n\nTests the metadata interface for a metadata wrapper (WrapperType) for binding instances of type X. It returns the results of attach_metadata(x, Dict{Symbol,Any}()) for further testing.\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.unsafe_attach_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.unsafe_attach_metadata","text":"unsafe_attach_metadata(x, m)\n\nAttaches metadata m to x without checking for compatability. New types for wrapping binding metadata to x should usually  define a unique unsafe_attach_metadata method.\n\nSee also attach_metadata\n\n\n\n\n\n","category":"method"},{"location":"#Metadata.@attach_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.@attach_metadata","text":"@attach_metadata(x, meta)\n\nAttach metadata meta to the object id of x (objectid(x)) in the current module's global metadata.\n\nSee also: GlobalMetadata\n\n\n\n\n\n","category":"macro"},{"location":"#Metadata.@copy_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.@copy_metadata","text":"@copy_metadata(src, dst) -> attach_metadata(dst, copy(metadata(src)))\n\nCopies the metadata from src by attaching it to dst. This assumes that metadata for src is stored in a global dictionary (i.e. not part of src's structure) and attaches a new copy to dst through a global reference within the module.\n\nSee also: @share_metadata, copy_metadata\n\n\n\n\n\n","category":"macro"},{"location":"#Metadata.@has_metadata-Tuple{Any}","page":"Metadata","title":"Metadata.@has_metadata","text":"@has_metadata(x)::Bool\n@has_metadata(x, k)::Bool\n\nDoes x have metadata stored in the curren modules' global metadata? Checks for the presenece of the key k if specified.\n\n\n\n\n\n","category":"macro"},{"location":"#Metadata.@metadata!-Tuple{Any, Any, Any}","page":"Metadata","title":"Metadata.@metadata!","text":"@metadata!(x, k, val)\n\nSet the value of x's global metadata associated with the key k to val.\n\n\n\n\n\n","category":"macro"},{"location":"#Metadata.@metadata-Tuple{Any}","page":"Metadata","title":"Metadata.@metadata","text":"@metadata(x[, k])\n\nRetreive metadata associated with the object id of x (objectid(x)) in the current module's global metadata. If the key k is specified only the value associated with that key is returned.\n\n\n\n\n\n","category":"macro"},{"location":"#Metadata.@share_metadata-Tuple{Any, Any}","page":"Metadata","title":"Metadata.@share_metadata","text":"@share_metadata(src, dst) -> @attach_metadata(@metadata(src), dst)\n\nShares the metadata from src by attaching it to dst. This assumes that metadata for src is stored in a global dictionary (i.e. not part of src's structure) and attaches it to dst through a global reference within the module.\n\nSee also: @copy_metadata, share_metadata\n\n\n\n\n\n","category":"macro"}]
}
