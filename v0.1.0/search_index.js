var documenterSearchIndex = {"docs":
[{"location":"#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"","page":"Metadata","title":"Metadata","text":"Metadata","category":"page"},{"location":"#Metadata","page":"Metadata","title":"Metadata","text":"Metadata.jl\n\n(Image: Build Status) (Image: stable-docs) (Image: dev-docs)\n\nIntroduction\n\nThe Metadata package provides a generic interface for interacting with metadata in Julia. This package typically assumes metadata to be a collection of of values paired to Symbol keys (e.g., Dict{Symbol}, NamedTuple). However, metadata that doesn't perfectly fit this criteria should still work with most methods if adhering to the basic interface.\n\nInterface\n\nThere are two types of interfaces in Metadata.\n\nAttaching metadata to other data\nNew types of metadata\n\nNew Metadata Glue Structure\n\nA new structure of type T that glues some data x to metadata meta require the following methods:\n\nRequired methods\nMetadata.metadata(x) -> meta: returns the metadata\nMetadata.metadata_type(::Type{T}): returns the type of the metadata, where T is the glue structure\nOptional methods:\nBase.parent(x): returns the instance attached to the metadata\nattach_metadata(x, m) -> T(x, m): returns an instance of T that has the metadata m attached to x.\n\nattach_metadata is only necessary if there is a specific type that you want to have a fall back for attaching metadata to. For example, if one wanted to attach metadata to all subtypes of AbstractGraph via MetaGraph then one could define Metadata.attach_metadata(g::AbstractGraph, m) = MetaGraph, g, m).\n\nNew Types of Metadata\n\nRequired methods:\nMetadata.metadata: should return the same instance because meta is it's own metadata\nMetadata.metadata_type\nOptional methods:\nMetadata.metadata_keys: return iterator of metadata's keys\nMetadataPropagation(::Type{T}): should metadata be dropped, shared, or copied.\n\n\n\n\n\n","category":"module"},{"location":"#Public","page":"Metadata","title":"Public","text":"","category":"section"},{"location":"","page":"Metadata","title":"Metadata","text":"Metadata.attach_metadata\nMetadata.has_metadata\nMetadata.metadata\nMetadata.metadata!\nMetadata.copy_metadata\nMetadata.drop_metadata\nMetadata.share_metadata","category":"page"},{"location":"#Metadata.attach_metadata","page":"Metadata","title":"Metadata.attach_metadata","text":"attach_metadata(x, metadata)\n\nGeneric method for attaching metadata to x.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.has_metadata","page":"Metadata","title":"Metadata.has_metadata","text":"has_metadata(x[, k; dim]) -> Bool\n\nReturns true if x has metadata. If k is specified then checks for the existence of a metadata paired to k. If dim is specified then this checks the metadata at the corresponding dimension.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.metadata","page":"Metadata","title":"Metadata.metadata","text":"metadata(x[, k; dim])\n\nReturns metadata from x. If k is specified then the metadata value paired to k is returned. If dim is specified then the operation is performed for metadata specific to dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.metadata!","page":"Metadata","title":"Metadata.metadata!","text":"metadata!(x, k, val[; dim])\n\nSet x's metadata paired to k to val. If dim is specified then the metadata corresponding to that dimension is mutated.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.copy_metadata","page":"Metadata","title":"Metadata.copy_metadata","text":"copy_metadata(src, dst) -> attach_metadata(dst, copy(metadata(src)))\n\nCopies the the metadata from src and attaches it to dst. Note that this method specifically calls deepcopy on the metadata of src to ensure that changing the metadata of dst does not affect the metadata of src.\n\nSee also: share_metadata.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.drop_metadata","page":"Metadata","title":"Metadata.drop_metadata","text":"drop_metadata(x)\n\nReturns x without metadata attached.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.share_metadata","page":"Metadata","title":"Metadata.share_metadata","text":"share_metadata(src, dst) -> attach_metadata(dst, metadata(src))\n\nShares the metadata from src by attaching it to dst. The returned instance will have properties that are synchronized with src (i.e. modifying one's metadata will effect the other's metadata).\n\nSee also: copy_metadata.\n\n\n\n\n\n","category":"function"},{"location":"#Internal","page":"Metadata","title":"Internal","text":"","category":"section"},{"location":"","page":"Metadata","title":"Metadata","text":"Metadata.NoMetadata\nMetadata.metadata_summary\nMetadata.MetaArray\nMetadata.MetaRange\nMetadata.MetaUnitRange\nMetadata.MetadataPropagation\nMetadata.CopyMetadata\nMetadata.DropMetadata\nMetadata.ShareMetadata","category":"page"},{"location":"#Metadata.NoMetadata","page":"Metadata","title":"Metadata.NoMetadata","text":"NoMetadata\n\nInternal type for the Metadata package that indicates the absence of any metadata. DO NOT store metadata with the value NoMetadata().\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.metadata_summary","page":"Metadata","title":"Metadata.metadata_summary","text":"metadata_summary(x; left_pad::Int=0, l1=lpad(`•`, 3), l2=lpad('-', 5))\n\nCreates summary readout of metadata for x.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata.MetaArray","page":"Metadata","title":"Metadata.MetaArray","text":"MetaArray(parent::AbstractArray, metadata)\n\nCustom AbstractArray object to store an AbstractArray parent as well as some metadata.\n\nExamples\n\njulia> using Metadata\n\njulia> Metadata.MetaArray(ones(2,2), metadata=(m1 =1, m2=[1, 2]))\n2×2 attach_metadata(::Array{Float64,2}, ::NamedTuple{(:m1, :m2),Tuple{Int64,Array{Int64,1}}})\n  • metadata:\n    - m1 = 1\n    - m2 = [1, 2]\n 1.0  1.0\n 1.0  1.0\n\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetaRange","page":"Metadata","title":"Metadata.MetaRange","text":"MetaRange(x::AbstractRange, meta)\n\nType for storing metadata alongside a range.\n\nExamples\n\njulia> using Metadata\n\njulia> Metadata.MetaRange(1:1:2, (m1 =1, m2=[1, 2]))\nattach_metadata(1:1:2, ::NamedTuple{(:m1, :m2),Tuple{Int64,Array{Int64,1}}})\n  • metadata:\n    - m1 = 1\n    - m2 = [1, 2]\n\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetaUnitRange","page":"Metadata","title":"Metadata.MetaUnitRange","text":"MetaUnitRange(x::AbstractUnitRange, meta)\n\nType for storing metadata alongside a anything that is subtype of AbstractUnitRange.\n\nExamples\n\njulia> using Metadata\n\njulia> Metadata.MetaUnitRange(1:2, (m1 =1, m2=[1, 2]))\nattach_metadata(1:2, ::NamedTuple{(:m1, :m2),Tuple{Int64,Array{Int64,1}}})\n  • metadata:\n    - m1 = 1\n    - m2 = [1, 2]\n\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.MetadataPropagation","page":"Metadata","title":"Metadata.MetadataPropagation","text":"MetadataPropagation(::Type{T})\n\nReturns type informing how to propagate metadata of type T. See DropMetadata, CopyMetadata, ShareMetadata.\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.CopyMetadata","page":"Metadata","title":"Metadata.CopyMetadata","text":"CopyMetadata\n\nInforms operations that may propagate metadata to attach a copy to any new instance created.\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.DropMetadata","page":"Metadata","title":"Metadata.DropMetadata","text":"DropMetadata\n\nInforms operations that may propagate metadata to insead drop it.\n\n\n\n\n\n","category":"type"},{"location":"#Metadata.ShareMetadata","page":"Metadata","title":"Metadata.ShareMetadata","text":"ShareMetadata\n\nInforms operations that may propagate metadata to attach a the same metadata to any new instance created.\n\n\n\n\n\n","category":"type"}]
}
